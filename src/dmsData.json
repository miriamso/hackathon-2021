[
  {
    "id": 1503,
    "language": "en-us",
    "name": "Java_High_Risk -> SQL_Injection",
    "resultDescription": "The application's @DestinationMethod method executes an SQL query with @DestinationElement, at line @DestinationLine of @DestinationFile. The application constructs this SQL query by embedding an untrusted string into the query without proper sanitization. The concatenated string is submitted to the database, where it is parsed and executed accordingly.\n\nAn attacker would be able to inject arbitrary syntax and data into the SQL query, by crafting a malicious payload and providing it via the input @SourceElement; this input is then read by the @SourceMethod method at line @SourceLine of @SourceFile. This input then flows through the code, into a query and to the database server - without sanitization.\n\nThis may enable an SQL Injection attack.\n\n",
    "risk": "An attacker could directly access all of the system's data. The attacker would likely be able to steal any sensitive information stored by the system, including private user information, credit card details, proprietary business data, and any other secret data. Likewise, the attacker could possibly modify or erase existing data, or even add new bogus data. In some scenarios, it may even be possible to execute code on the database. \n\nIn addition to disclosing or altering confidential information directly, this vulnerability might also be used to achieve secondary effects, such as bypassing authentication, subverting security checks, or forging a data trail. \n\nFurther increasing the likelihood of exploit is the fact that this flaw is easy for attackers to find, and easy to exploit.\n\n",
    "cause": "The application stores and manages data in a database, by submitting a textual SQL query to the database engine for processing. The application creates the query by simple string concatenation, embedding untrusted data. However, there is no separation between data and code; furthermore, the embedded data is neither checked for data type validity nor subsequently sanitized. Thus, the untrusted data could contain SQL commands, or modify the intended query. The database would interpret the altered query and commands as if they originated from the application, and execute them accordingly.\n\nNote that an attacker can exploit this vulnerability either by modifying the URL, or by submitting malicious data in the user input or other request fields.\n\n",
    "generalRecommendations": "*   Validate all untrusted data, regardless of source. Validation should be based on a whitelist: accept only data fitting a specified structure, rather than reject bad patterns. \n*   In particular, check for:\n    *   Data type\n    *   Size\n    *   Range\n    *   Format\n    *   Expected values.\n*   Restrict access to database objects and functionality, according to the Principle of Least Privilege.\n*   Do not use dynamically concatenate strings to construct SQL queries. \n*   Prefer using DB Stored Procedures for all data access, instead of ad-hoc dynamic queries. \n*   Instead of unsafe string concatenation, use secure database components such as parameterized queries and object bindings (for example, commands and parameters). \n*   Alternatively, an even better solution is to use an ORM library, in order to pre-define and encapsulate the allowed commands enabled for the application, instead of dynamically accessing the database directly. In this way the code plane and data plane should be isolated from each other.\n*   Data validation can be performed effectively using a secure library, such as OWASP's Encoder or ESAPI libraries. \n*   Prefer using `PreparedStatement` for parameterizing the queries, or even better `CallableStatement`. Add dynamic data via the `.set*()` methods, instead of string concatenation. \n*   Consider using an ORM package, such as `Hibernate`, `myBatis`, or others.",
    "insertDate": "2020-09-10T11:26:54.93",
    "codeSample": [
      {
        "title": "Create SQL query using string concatenation",
        "sourceCodeExample": "public int getUserId(HttpServletRequest request) \n        throws ServletException, IOException {\n    int userId = 0;\n    \n    String userName = request.getParameter(\"UserName\");\n    String sql = \"SELECT [UserID] FROM [AppUsers] WHERE [UserName] = '\" + userName + \"' \" ;\n\n    try {\n        Connection conn = getConnection(); \n        Statement stmt = conn.createStatement(); \n        ResultSet data = stmt.executeQuery(sql);\n        \n        userId = data.getInt(1);        \n    } catch (SQLException ex) {\n        handleExceptions(ex);\n    }\n    finally {\n        closeQuietly(data);\n        closeQuietly(stmt);\n        closeQuietly(conn);\n    }\n    \n    return userId;\n}",
        "programmingLanguage": "Java",
        "vulnerable": true
      },
      {
        "title": "Create SQL query using Sanitized Username",
        "sourceCodeExample": "public int getUserId(HttpServletRequest request) \n        throws ServletException, IOException {\n    int userId = 0;\n    \n    String userName = request.getParameter(\"UserName\");\n\n    // Sanitize input using OWASP's ESAPI Encoder library\n    //   Still not complete solution!\n    Encoder esapiEncoder = new DefaultEncoder();\n    String sanitizedUserName = esapiEncoder.encodeForSQL(new OracleCodec(), userName); \n\n    String sql = \"SELECT [UserID] FROM [AppUsers] WHERE [UserName] = '\" + sanitizedUserName + \"' \" ;\n\n    try {\n        Connection conn = getConnection(); \n        Statement stmt = conn.createStatement(); \n        ResultSet data = stmt.executeQuery(sql);\n        \n        userId = data.getInt(1);        \n    } catch (SQLException ex) {\n        handleExceptions(ex);\n    }\n    finally {\n        closeQuietly(data);\n        closeQuietly(stmt);\n        closeQuietly(conn);\n    }\n    \n    return userId;\n}",
        "programmingLanguage": "Java",
        "vulnerable": false
      },
      {
        "title": "Build PreparedStatement to call Stored Procedure and set input to parameters",
        "sourceCodeExample": "public int getUserId(HttpServletRequest request) \n        throws ServletException, IOException {\n    int userId = 0;\n    \n    String userName = request.getParameter(\"UserName\");\n    String sqlStoredProc = \"{call getUserId (?, ?)}\";\n\n    try {\n        Connection conn = getConnection(); \n        CallableStatement stmt = conn.prepareCall(sqlStoredProc); \n        \n        stmt.setString(1, userName);         \n        stmt.registerOutParameter(2, java.sql.Types.INTEGER);\n\n        stmt.execute();\n        userId = stmt.getInt(2);\n    } catch (SQLException ex) {\n        handleExceptions(ex);\n    }\n    finally {\n        closeQuietly(stmt);\n        closeQuietly(conn);\n    }\n    \n    return userId;\n}",
        "programmingLanguage": "Java",
        "vulnerable": false
      }
    ]
  }
]
